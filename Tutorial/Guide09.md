# 学习Python的第九天

任务:
- 学习一些Python中的高级特性
    - 掌握切片
    - 掌握迭代过程
    - 掌握列表生成器的用法

前一天我们学习了Python中的一些进阶数据结构。当然，在字符串处理和控制流那部分也见识了一些Python中的高阶特性。今天就分别来详细了解下他们。

## 切片Slice
**切片**，简单来说，就是取一个list或tuple的部分元素。比如，有一个`list`如下:
```python
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
```
如果我们要取前三个元素，要怎么做？
是直接把前三个元素单独拎出来，重新组合成一个`list`？
```
>>> [L[0], L[1], L[2]]
['Michael', 'Sarah', 'Tracy']
```
那么，稍微扩展一下，取前`n`项元素的话：
```
>>> r = []
>>> n = 3
>>> for i in range(n):
        r.append(L[i])

>>> r
['Michael', 'Sarah', 'Tracy']
```
但是这样看着就麻烦，所以Python给我们提供了一个新的功能—— **切片（Slice）** 
```
>>> L[0:3] # using Slice
['Michael', 'Sarah', 'Tracy']
```

`L[0:3]`表示，从索引`0`开始取，直到索引`3`为止，**但不包括索引`3`**。即索引`0`，`1`，`2`，正好是3个元素。

如果第一个索引是`0`，还可以省略：
```
>>> L[:3]
['Michael', 'Sarah', 'Tracy']
```
也可以从索引`1`开始，取出2个元素出来：
```
>>> L[1:3]
['Sarah', 'Tracy']
```
类似的，既然Python支持`L[-1]`取倒数第一个元素，那么它同样支持倒数切片，试试：
```
>>> L[-2:]
['Bob', 'Jack']
>>> L[-2:-1]
['Bob']
```
记住倒数第一个元素的索引是`-1`。

切片操作十分有用。我们先创建一个`0-99`的数列：
```
>>> L = list(range(100))
>>> L
[0, 1, 2, 3, ..., 99]
```
可以通过切片轻松取出某一段数列。比如前10个数：
```
>>> L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
后10个数：
```
>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
```
前11-20个数：
```
>>> L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
```
前10个数，每两个取一个：
```
>>> L[:10:2]
[0, 2, 4, 6, 8]
```
所有数，每5个取一个：
```
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
```
甚至什么都不写，只写`[:]`就可以原样复制一个`list`：
```
>>> L[:]
[0, 1, 2, 3, ..., 99]
```
`tuple`也是一种`list`，唯一区别是`tuple`不可变。因此，`tuple`也可以用切片操作，只是操作的结果仍是`tuple`：
```
>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
```
字符串`'xxx'`也可以看成是一种`list`，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：
```
>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACEG'
```
> 在很多编程语言中，针对字符串提供了很多各种截取函数（例如，`substring()`），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。

## 迭代 Iteration
如果给定一个`list`或`tuple`，我们可以通过`for`循环来遍历这个`list`或`tuple`，这种遍历我们称为 **迭代（Iteration）** 。

在Python中，迭代是通过`for ... in`来完成的。Python的`for`循环不仅可以用在`list`或`tuple`上，还可以作用在其他可迭代对象上。

`list`这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如`dict`就可以迭代：
```
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> for key in d:
...     print(key)
...
a
c
b
```
因为`dict`的存储不是按照`list`的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

默认情况下，`dict`迭代的是`key`。如果要迭代`value`，可以用`for value in d.values()`，如果要同时迭代`key`和`value`，可以用`for k, v in d.items()`。

由于字符串也是可迭代对象，因此，也可以作用于for循环：
```
>>> for ch in 'ABC':
...     print(ch)
...
A
B
C
```
所以，当我们使用`for`循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是`list`还是其他数据类型。

那么，如何判断一个对象是可迭代对象呢？方法是通过`collections`模块的`Iterable`类型判断：
```
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False
```
最后，同时引用了两个变量，在Python里是很常见的，比如下面的代码：
```
>>> for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9
```

## 列表生成器 List Comprehensions
列表生成式，是Python内置的非常简单的可以用来创建list的生成式。

举个例子，要生成`list` `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10`]可以用`list(range(1, 11))`：
```
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
但如果要生成`[1x1, 2x2, 3x3, ..., 10x10]`怎么做？方法一是循环：
```
>>> L = []
>>> for x in range(1, 11):
...    L.append(x * x)
...
>>> L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```
但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的`list`：
```
>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```
写列表生成式时，把要生成的元素`x * x`放到前面，后面跟`for`循环，就可以把`list`创建出来，十分有用，多写几次，很快就可以熟悉这种语法。

`for`循环后面还可以加上`if`判断，这样我们就可以筛选出仅偶数的平方：
```
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
```
还可以使用两层循环，可以生成全排列：
```
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```
三层和三层以上的循环就很少用到了。

运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：
```
>>> import os # 导入os模块，模块的概念后面讲到
>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']
```
for循环其实可以同时使用两个甚至多个变量，比如`dict`的`items()`可以同时迭代`key`和`value`：
```
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
```
因此，列表生成式也可以使用两个变量来生成`list`：
```
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']
```
最后把一个`list`中所有的字符串变成小写：
```
>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
```
### `if ... else`
使用列表生成式的时候，有些童鞋经常搞不清楚`if...else`的用法。

例如，以下代码正常输出偶数：
```
>>> [x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]
```
观察下面的栗子：
```
>>> [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
```
上述for前面的表达式`x if x % 2 == 0 else -x`才能根据x计算出确定的结果。

可见，在一个列表生成式中，`for`前面的`if ... else`是表达式，而`for`后面的`if`是过滤条件，不能带`else`。



<p align="center">
  <a href="Guide08.md">上一篇教程</a>  --------------------------------------  <a href="Guide10.md">下一篇教程
</p>